;8-Бит Чаепитие! 2021.
;Лицензия: Creative Commons.
;Платформа: 8086, VGA(256Kb).
;Инструменты: NASM.
;Модули: VGA-X,...
;Авторы: Данила Перов(peroff@protonmail.com).
;Быстродействие: примерное количество тактов для каждой процедуры.
;Память: процед_1 = N, процед_2 занимает М байт.
;Краткая история изменений:
;ДД.ММ.ГГ, И.И.: Короткое сообщение что добавлено, удалено или исправлено.

%include "VGA-X.ASM"            ;Директива включения заголовка для NASM.

;Полный комплект, при условии если всё ок, то до 13-20 ноября.
;Базовый вариант, через недельку-две-три, буква.

;Процедуры печати в экранную память режима Х, нашего 16-ти битного формата
;строк. Смотри файл string.asm для подробного описания формата.
;Использует дополнительно пару глобальных параметров: шрифт по умолчанию и
;текущие позиции вывода для удобства вызовов. Для старта можно взять пока
;системный шрифт ВГА адаптера. Его можно получить при вызове функции.
;Шрифт минимально черно-белый размеры были по умолчанию 8*8.


;Глобальные переменные и константы, когда будет доделано, то скинем их в
;общий файл библиотеки режима Х.


vx_cursor_x     dw 0000h        ;Левая точка позиции курсора, 0..319.
vx_cursor_y     dw 0000h        ;Верхняя точка позиции курсора, 0..239.
vx_font_addr    dd 00000000h    ;Полный адрес шрифта, смещение и сегмент.
vx_font_first_c db 00h          ;Код первого символа в шрифте.
vx_font_chars   db 00h          ;Количество символов в шрифте, 0 = 256.
vx_font_char_b  db 00h          ;Количество байт на один символ.
vx_font_width   db 00h          ;Ширина символа в точках.
vx_font_height  db 00h          ;Высота символа в линиях.

;Биты, задающие масштаб, в параметрах функций VXPrintChar и VXPrintString
SYMBOL_SCALE_MASK EQU 00001111b

;Если потребуются вспомогательные процедуры работы со шрифтом, то добавляй
;временно прямо сюда, если что подумаем позже об отдельном файле. VXFontLoad.

;Загружаем в глобальные переменные адрес и прочие данные системного шрифта
;по умолчанию, размер: 8x8.
;Вход:  нет;
;Выход: измененные глобальные переменные vx_font_*
LoadDefaultFont:
        pushf
        push ax
        push bx
        push cx
        push dx
        push bp
        push es

        mov ax,1130h                    ; получить параметры шрифта из BIOS
        mov bh,3                        ; выбираем шрифт 8x8
        int 10h
        mov ax,es
        mov [vx_font_addr],ax           ; сегмент данных шрифта
        mov [vx_font_addr + 2],bp       ; смещение данных шрифта
        mov byte [vx_font_chars],0      ; количество символов в шрифте, 0=256
        mov byte [vx_font_char_b],8     ; байтов на один символ
        mov byte [vx_font_width],8      ; ширина символа
        mov byte [vx_font_height],8     ; высота символа

        pop es
        pop bp
        pop dx
        pop cx
        pop bx
        pop ax
        popf
        ret

;Дополнительно, только если уже ниже процедуры реализованы.
;Всё по аналогии, только с учетом вывода в окно.
;Параметры пока подумаем, но главное, что бы вывод шел с ограничением
;относительно логического окна, а не экрана и плюс с разными дополнительными
;возможностями.

VXPrintStrWin:
        pushf
        popf
        ret


;Процедура печати грфической строки на экран в режиме Х, по координатам.
;Печать использует глобальные параметры по-умолчанию: позиция, шрифт и т.д.
;При выходе за пределы экрана, выходим тихо.
;Вход:
;AH     биты:
;0..2   масштабирование для символов, 1..8(сначала просто масштаб 1х);
;4      резерв
;5      печатать по одному символу, запомнить состояние и выйти, чтобы
;       уложится в один кадр;
;6      останавливать вывод при достижении конца горизонтального вывода;
;7      переносить или нет глобальные координаты печати;
;DS:BX  адрес строки;
;Выход: измененный видеобуффер в активной странице и если бит 7, то и курсор.

VXPrintString:
        pushf
        popf
        ret


;Процедура печати графического символа на экран в режим Х, по координатам.
;Пока что использовать шрифт и позицию глобальную, параметры шрифта так же.
;После исполнения сдвигаем позицию слева направо на размер шрифта, если не
;влезает вправо, то переносим на следующую строку, так же по размеру шрифта
;по вертикали.
;Вход:
;AL     символ для вывода;
;AH     биты:
;  0..3   масштабирование для символа, 1..16;
;  4..7   резерв, здесь можно стиль вывода будет сделать, задержку,
;         маску и т.д.
;DL     цвет символа
;Выход: измененный видеобуффер в активной странице.

VXPrintChar:
        ; сохраняем регистры, сегментные сохраним позже
        pushf
        push ax
        push bx
        push cx
        push dx
        push si
        push di
        push bp
        cld                             ; направление - вперед

        ; основные параметры отрисовки храним в BX, он не меняется до
        ; выхода из функции:
        ; BL - цвет
        ; BH - битовые параметры (включая масштабирование)
        mov bh,ah
        mov bl,dl

        ; проверяем, есть ли нужный символ в текущем шрифте
        mov cl,[vx_font_first_c]        ; код первого символа в шрифте
        cmp al,cl
        jnb short PrntChr0
PrntChrJExit:
        jmp near PrntChrExit            ; слишком далеко для условного short
PrntChr0:
        mov dl,[vx_font_chars]          ; количество символов в шрифте
        add dl,cl
        dec dl                          ; DL = код последнего символа
        cmp al,dl
        ja short PrntChrJExit

        ; находим адрес образа нужного символа:
        ; addr = (code-first_code)*symbol_size + font_addr
        mov si,[vx_font_addr + 2]       ; смещение шрифта
        sub al,cl                       ; code - first_code
        mov dl,[vx_font_char_b]         ; ширина символа в байтах
        mul dl
        add si,ax

        mov ch,bh                       ; битовые параметры
        and ch,SYMBOL_SCALE_MASK        ; выделяем масштабирование
        inc ch                          ; CH = коэфф-т масштабирования

        ; проверяем, можно ли полностью вписать символ в текущую позицию на
        ; экране, если нет - на выход
        mov di,[vx_cursor_x]            ; позиция курсора по X
        mov al,[vx_font_width]          ; ширина символа
        mul ch                          ; реальная ширина с учетом масштаба
        add ax,di                       ; первый пиксель справа после символа
        cmp ax,GFX_SCR_WIDTH            ; не выйдем ли за экран
        ja short PrntChrJExit
        mov dx,[vx_cursor_y]            ; позиция курсора по Y
        mov al,[vx_font_height]         ; высота символа
        mul ch                          ; реальная высота с учетом масштаба
        add ax,dx                       ; первый пиксель снизу после символа
        cmp ax,GFX_SCR_HEIGHT           ; не выйдем ли за экран
        ja short PrntChrJExit
        ; считаем адрес верхнего левого угла символа в видеопамяти:
        ; DI = Y * GFX_BYTES_PER_LINE + (X >> 2) + active_page
        mov ax,dx                       ; Y курсора
        mov dx,GFX_BYTES_PER_LINE
        mul dx
        shr di,1                        ; X курсора >> 2
        shr di,1
        add di,ax
        add di,[vx_scr_active]          ; начало активной видеостраницы

        ; предрасчет смещения вниз на K строк экрана, где K = масштаб
        mov al,ch                       ; масштаб
        mov dl,GFX_BYTES_PER_LINE
        mul dl
        mov bp,ax                       ; сохраняем в BP для использования
                                        ; в цикле потом

        mov ch,[vx_font_height]         ; CH = высота символа, счетчик цикла
        mov cl,[vx_font_width]
        mov dl,cl                       ; DL = ширина символа
        and cl,00000011b
        mov dh,00000001b
        shl dh,cl                       ; DH = начальная маска битовых планов

        ; сохраняем и заменяем сегментные регистры
        push ds
        push es
        mov ax,[vx_font_addr]
        mov ds,ax                       ; DS = сегмент шрифта
        mov ax,GFX_SCR_ADDR
        mov es,ax                       ; ES = видеобуфер

        ; AL - битовый буфер для чтения шрифта
        ; AH - текущее количество битов в нем
        mov ah,0

; for (y = 0; y < font_height; y++)
;   for (x = 0; x < font_width; x++)
;     for (n1 = 1; n1 <= scale; n1++)
;       if (pixels[x])
;         for (n2 = 1; n2 <= scale; n2++)
;           drawPixel()

        ; рисуем следующую линию шрифта
PrntChr1:
        mov cl,dl                       ; CL = ширина символа, счетчик цикла
        push di                         ; сохраняем текущий адрес линии
        push dx                         ; DH - маска планов для первого пикселя,
                                        ; DL - ширина символа

        ; рисуем следующую точку (пиксель) шрифта
PrntChr3:
        test ah,ah                      ; если буфер шрифта пуст, то...
        jnz short PrntChr2
        lodsb                           ; загружаем в него очередные 8 бит
        mov ah,8                        ; кол-во бит в буфере
PrntChr2:
        mov dl,bh                       ; битовые параметры
        and dl,SYMBOL_SCALE_MASK        ; выделяем масштабирование
        inc dl                          ; коэфф-т масштабирования, счетчик

        ; каждую точку шрифта масштабируем по горизонтали в DL раз,
        ; повторяя рисование одного и того же пикселя несколько раз
PrntChr4:
        test al,10000000b               ; если в шрифте точка не закрашена,
        jz short PrntChr6               ; пропускаем рисование

        ; масштабируем по вертикали, рисуем "столбик" из закрашенных пикселей
        ; высотой, равной коэфф-у масштабирования
        push ax
        push dx
        mov ah,dh                       ; маска битовых планов
        mov al,02h                      ; адрес регистра VGA
        mov dx,VGA_SEQUENCER_ADDR
        out dx,ax                       ; пишем в регистр маски
        mov ax,di                       ; сохраняем текущий адрес в буфере
        mov dl,bh                       ; битовые параметры
        and dl,SYMBOL_SCALE_MASK        ; выделяем масштабирование
        inc dl                          ; коэфф-т масштабирования
PrntChr5:
        mov byte es:[di],bl             ; пишем в видеобуфер
        add di,GFX_BYTES_PER_LINE       ; переходим на линию ниже
        dec dl
        jnz short PrntChr5              ; следующий пиксель в столбике
        mov di,ax                       ; восстанавливаем позицию
        pop dx
        pop ax

PrntChr6:
        shl dh,1                        ; сдвигаем маску планов
        cmp dh,00001000b
        jna PrntChr7
        mov dh,00000001b                ; циклически младшие 4 бита
        inc di                          ; каждые 4 пикселя сдвигаем позицию
PrntChr7:
        dec dl
        jnz short PrntChr4              ; следующий повтор той же точки шрифта

        shl al,1                        ; выкидываем бит шрифта из буфера
        dec ah                          ; бит_в_буфере--
        dec cl
        jnz short PrntChr3              ; следующая точка шрифта

        pop dx                          ; DH - маска планов для первого пикселя,
                                        ; DL - ширина символа
        pop di                          ; позиция начала строки
        add di,bp                       ; сдвигаем вниз на N=масштаб строк

        dec ch
        jnz short PrntChr1              ; следующая строка шрифта

        ; восстанавливаем сегментные регистры (и доступ к переменным)
        pop es
        pop ds

        ; сдвигаем курсор на ширину символа (с учетом масштаба), проверяем,
        ; влезет ли еще один символ на ту же строку; если нет, спускаемся
        ; на следующую
        mov ch,bh                       ; битовые параметры
        and ch,SYMBOL_SCALE_MASK        ; выделяем масштабирование
        inc ch                          ; коэфф-т масштабирования
        mov dx,[vx_cursor_x]            ; X курсора
        mov al,[vx_font_width]          ; ширина символа
        mul ch                          ; умножаем на масштаб
        add dx,ax                       ; первый пиксель справа после символа
        mov [vx_cursor_x],dx            ; = новая позиция курсора
        add dx,ax                       ; а еще символ влезет?
        cmp dx,GFX_SCR_WIDTH
        jna short PrntChrExit           ; если да, то на выход
        mov dx,[vx_cursor_y]            ; Y курсора
        mov al,[vx_font_height]         ; высота символа
        mul ch                          ; умножаем на масштаб
        add dx,ax
        mov [vx_cursor_y],dx            ; сдвигаем курсор на строчку ниже
        xor ax,ax
        mov [vx_cursor_x],ax            ; и ставим в начало строки

PrntChrExit:
        ; восстанавливаем регистры
        pop bp
        pop di
        pop si
        pop dx
        pop cx
        pop bx
        pop ax
        popf
        ret
