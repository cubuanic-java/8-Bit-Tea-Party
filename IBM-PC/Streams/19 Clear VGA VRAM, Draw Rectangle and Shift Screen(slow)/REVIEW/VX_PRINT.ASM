;8-Бит Чаепитие! 2021.
;Лицензия: Creative Commons.
;Платформа: 8086, VGA(256Kb).
;Инструменты: NASM.
;Модули: VGA-X,...
;Авторы: Данила Перов(peroff@protonmail.com).
;Быстродействие: примерное количество тактов для каждой процедуры.
;Память: процед_1 = N, процед_2 занимает М байт.
;Краткая история изменений:
;ДД.ММ.ГГ, И.И.: Короткое сообщение что добавлено, удалено или исправлено.

%include "VGA-X.ASM"            ;Директива включения заголовка для NASM.

;Минимальный комплект, при условии если всё ок, то до 14 ноября.
;Печать строки пока без окна, используя наш формат и с параметром смещения и
;количеством символов для печати. Остальное уже будем шлифовать после.


; Процедуры печати в экранную память режима Х, нашего 16-ти битного формата
;строк. Смотри файл string.asm для подробного описания формата.
; Использует дополнительно пару глобальных параметров: шрифт по умолчанию и
;текущие позиции вывода для удобства вызовов. Для старта можно взять пока
;системный шрифт ВГА адаптера. Его можно получить при вызове функции.
;Шрифт минимально черно-белый размеры были по умолчанию 8*8.


; Глобальные переменные и константы, когда будет доделано, то скинем их в
;общий файл библиотеки режима Х.


;Биты, задающие масштаб, в параметрах функций VXPrintChar и VXPrintString
CHAR_SCALE_MASK         EQU 00001111b


vx_cursor_x     dw 0000h        ;Левая точка позиции курсора, 0..319.
vx_cursor_y     dw 0000h        ;Верхняя точка позиции курсора, 0..239.
vx_font_addr    dd 00000000h    ;Полный адрес шрифта, смещение и сегмент.
vx_font_first_c db 00h          ;Код первого символа в шрифте.
vx_font_chars   db 00h          ;Количество символов в шрифте, 0 = 256.
vx_font_char_b  db 00h          ;Количество байт на один символ.

;! Пока оставим эту глобальную переменную, может пригодится.
;Но уже для шрифта будем использовать таблицу ширины для каждого символа.
vx_font_width   db 00h          ;Ширина символа в точках

;! Таблица ширины символов для печати, один байт, 1..255, если что после
;можно будет убавить и упаковать, но пока как удобней и быстрее. :)
vx_font_width_t db 0100h dup (08h)      ;Таблица ширины символов.

;! Высоту символов оставляем как есть, строчки текста стоит держать.
vx_font_height  db 00h          ;Высота символа в линиях.
vx_font_color   db 00h          ;Глобальный цвет для печати по-умолчанию.
vx_font_bkg     db 00h          ;Глобальный цвет фона, пока резерв.


;Загружаем в глобальные переменные адрес и прочие данные системного шрифта
;по умолчанию, размер: 8x8.
;Вход:  нет;
;Выход: измененные глобальные переменные vx_font_*

VXLoadFontBIOS:
        pushf
        push ax
        push bx
        push cx
        push dx
        push bp
        push es

        mov ax,1130h                    ; получить параметры шрифта из BIOS
        mov bh,3                        ; выбираем шрифт 8x8
        int 10h
        mov ax,es
        mov [vx_font_addr],ax           ; сегмент данных шрифта
        mov [vx_font_addr + 2],bp       ; смещение данных шрифта
        mov byte [vx_font_chars],0      ; количество символов в шрифте, 0=256
        mov byte [vx_font_char_b],8     ; байтов на один символ
        mov byte [vx_font_width],8      ; ширина символа
        mov byte [vx_font_height],8     ; высота символа
        mov byte [vx_font_color],7      ; цвет шрифта, серый по умолчанию
        mov byte [vx_font_bkg],0        ; цвет фона

        pop es
        pop bp
        pop dx
        pop cx
        pop bx
        pop ax
        popf
        ret


;Дополнительно, только если уже ниже процедуры реализованы.
;Всё по аналогии, только с учетом вывода в окно.
;Параметры пока подумаем, но главное, что бы вывод шел с ограничением
;относительно логического окна, а не экрана и плюс с разными дополнительными
;возможностями.

VXPrintStrWin:
        pushf
        popf
        ret


;Процедура печати графической строки на экран в режиме Х, по координатам.
;Печать использует глобальные параметры по-умолчанию: позиция, шрифт и т.д.
;При выходе за пределы экрана, выходим тихо.
;Вход:
;AH     биты:
;0..3   масштабирование для символов, 1..16;
;4      резерв
;5      печатать по одному символу, запомнить глобальные координаты и выйти,
;       чтобы уложиться в один кадр;
;6      останавливать вывод при достижении конца горизонтального вывода;
;7      переносить или нет глобальные координаты печати;
;AL     пока что количество символов для печати, если 0, то печать до конца
;       строки, или пока не закончится экран.
;DS:BX  адрес строки;
;DX     смещение в строке, символ с которого нужно начинать печатать.
;Выход: измененный видеобуффер в активной странице и если биты 5 или 7, то и
;       курсор.

VXPrintString:
        pushf                           ; сохраняем флаги и регистры
        push ax
        push bx
        push cx
        push dx
        push si
        push di
        push bp
        cld                             ; направление - вперед

;! Все проверки на месте, хорошо, даже как-то подзабыл команду JCXZ. :)

        mov cx,[bx]                     ; CX = длина строки
        jcxz PrntStrR                   ; если пустая строка, то выходим
        sub cx,dx                       ; если начальный символ за пределами
        jc short PrntStrR               ; строки, то выходим
        mov si,[bx + 02h]               ; смещение потока символов
        add si,bx                       ; + адрес строки
        add si,dx                       ; SI = адрес первого символа

        mov bx,ax                       ; BX = параметры печати

        ; запоминаем исходную позицию курсора
        mov di,[vx_cursor_x]
        mov bp,[vx_cursor_y]

        ; определяем эффективное количество символов, которое будем печатать
        test bh,00100000b               ; режим одиночного символа
        jz short PrntStr0

;! Всё на месте, понимаю что кратко, но пиши пожалуйста 1 - как 01h или шире
;для однообразия чисел во всех наших исходниках, и 0 также. ;)
        
        mov cx,1                        ; печатаем один символ
        jmp short PrntStr1
PrntStr0:
        mov ah,0                        ; обнулили старший байт
        test ax,ax                      ; если счетчик равен нулю,
        jz short PrntStr1               ; то не обрезаем строку
        cmp ax,cx                       ; сравниваем счетчик с исходной длиной
        jnb short PrntStr1
        mov cx,ax                       ; обрезаем до заданного кол-ва симв.

PrntStr1:
        ; готовим параметры для вызова VXPrintChar
        mov ah,bh
        and ah,CHAR_SCALE_MASK          ; AH = масштабирование
        mov dl,[vx_font_color]          ; DL = цвет шрифта

        ; цикл печати символов
PrntStrLp:
        lodsb                           ; загружаем очередной символ
        call near VXPrintChar           ; вызов печати
        test bh,01000000b               ; в режиме 6-го бита проверяем,
        jz short PrntStr2               ; не достигли ли правой границы экрана
        cmp [vx_cursor_y],bp            ; если изменился Y, значит достигли
        jne short PrntStr3              ; тогда выходим
PrntStr2:
        loop PrntStrLp                  ; следующий символ

PrntStr3:
        ; если не включен режим одиночного символа и не установлен бит 7, то
        ; восстанавливаем исходную позицию курсора
        test bh,10100000b
        jnz short PrntStrR
        mov [vx_cursor_x],di
        mov [vx_cursor_y],bp

;! В остальном, всё ок. Буду использовать пока эту процедуру, можно сохранить
;её к себе, и уже двигаться далее, процедура печати текста с произвольной
;шириной в пикселях.

PrntStrR:
        pop bp                          ; восстанавливаем регистры
        pop di
        pop si
        pop dx
        pop cx
        pop bx
        pop ax
        popf
        ret


;Процедура печати графического символа на экран в режим Х, по координатам.
;Пока что использовать шрифт и позицию глобальную, параметры шрифта так же.
;После исполнения сдвигаем позицию слева направо на размер шрифта, если не
;влезает вправо, то переносим на следующую строку, так же по размеру шрифта
;по вертикали.
;Процедура не накладывает никаких ограничений на размер шрифта (например,
;он может не быть кратен 8), кроме одного: ширина символа с учетом
;масштабирования не должна превышать 256 пикселей.
;Вход:
;AL     символ для вывода;
;AH     биты:
;  0..3   масштабирование для символа, 1..16;
;  4..7   резерв, здесь можно стиль вывода будет сделать, задержку,
;         маску и т.д.
;DL     цвет символа
;Выход: измененный видеобуффер в активной странице.

VXPrintChar:
        ; сохраняем регистры, сегментные сохраним позже
        pushf
        push ax
        push bx
        push cx
        push dx
        push si
        push di
        push bp
        cld                             ; направление - вперед

        ; основные параметры отрисовки храним в BX, он не меняется до
        ; выхода из функции:
        ; BL - цвет
        ; BH - битовые параметры (включая масштабирование)
        mov bh,ah
        mov bl,dl

        ; проверяем, есть ли нужный символ в текущем шрифте
        mov cl,[vx_font_first_c]        ; код первого символа в шрифте
        cmp al,cl
        jnb short PrntChr0

PrntChrJExit:
        jmp near PrntChrR               ; слишком далеко для условного short

PrntChr0:
        mov dl,[vx_font_chars]          ; количество символов в шрифте
        add dl,cl
        dec dl                          ; DL = код последнего символа
        cmp al,dl
        ja short PrntChrJExit

        ; находим адрес образа нужного символа:
        ; addr = (code-first_code)*symbol_size + font_addr
        mov si,[vx_font_addr + 2]       ; смещение шрифта
        sub al,cl                       ; code - first_code
        mov dl,[vx_font_char_b]         ; ширина символа в байтах
        mul dl
        add si,ax

        mov ch,bh                       ; битовые параметры
        and ch,CHAR_SCALE_MASK          ; выделяем масштабирование
        inc ch                          ; CH = коэфф-т масштабирования

        ; проверяем, можно ли полностью вписать символ в текущую позицию на
        ; экране, если нет - на выход
        mov di,[vx_cursor_x]            ; позиция курсора по X
        mov al,[vx_font_width]          ; ширина символа
        mul ch                          ; умножаем на масштаб
        test ax,ax
        jz short PrntChrJExit           ; нулевая ширина, ошибка
        add ax,di                       ; первый пиксель справа после символа
        cmp ax,GFX_SCR_WIDTH            ; не выйдем ли за экран
        ja short PrntChrJExit
        mov dx,[vx_cursor_y]            ; позиция курсора по Y
        mov al,[vx_font_height]         ; высота символа
        mul ch                          ; реальная высота с учетом масштаба
        test ax,ax
        jz short PrntChrJExit           ; нулевая высота, ошибка
        add ax,dx                       ; первый пиксель снизу после символа
        cmp ax,GFX_SCR_HEIGHT           ; не выйдем ли за экран
        ja short PrntChrJExit

        ; считаем адрес верхнего левого угла символа в видеопамяти:
        ; DI = Y * GFX_BYTES_PER_LINE + (X >> 2) + active_page
        mov ax,dx                       ; Y курсора
        mov dx,GFX_BYTES_PER_LINE
        mul dx
        shr di,1                        ; X курсора >> 2
        shr di,1
        add di,ax
        add di,[vx_scr_active]          ; начало активной видеостраницы

        ; предрасчет смещения вниз на K строк экрана, где K = масштаб
        mov al,ch                       ; масштаб
        mov dl,GFX_BYTES_PER_LINE
        mul dl
        mov bp,ax                       ; сохраняем в BP для использования
                                        ; в цикле потом

        mov ax,[vx_cursor_x]            ; позиция курсора по X
        mov cl,al
        and cl,00000011b
        mov al,00000001b
        shl al,cl
        mov cl,al                       ; CL = маска битовых планов для
                                        ; первого пикселя строки

        mov al,[vx_font_width]          ; ширина символа
        mul ch                          ; умножаем на масштаб
        cmp ax,100h
        ja short PrntChrJExit           ; реальная ширина больше 256, ошибка
        mov ch,al                       ; CH = ширина симв. с учетом масштаба,
                                        ; 0 = 256

        mov dl,[vx_font_height]         ; DL = высота символа, счетчик цикла

        ; сохраняем и заменяем сегментные регистры, после этого доступ к
        ; глобальным переменным будет невозможен
        push ds
        push es
        mov ax,[vx_font_addr]
        mov ds,ax                       ; DS = сегмент шрифта
        mov ax,GFX_SCR_ADDR
        mov es,ax                       ; ES = видеобуфер

        ; AL - битовый буфер для чтения шрифта
        ; AH - текущее количество битов в нем
        mov ah,0

PrntChr1:
        ; рисуем следующую линию шрифта
        push cx                         ; нач. маска и число пикселей в строке
        push dx                         ; счетчик строк
        push di                         ; позиция в видеобуфере

PrntChr2:
        ; формируем маску битовых планов для очередного блока пикселей
        mov dh,0                        ; DH = маска

PrntChr3:
        test ah,ah                      ; есть ли данные в буфере шрифта?
        jnz short PrntChr4
        lodsb                           ; читаем очередные 8 бит
        mov ah,08h                      ; bits = 8
        mov dl,bh                       ; битовые параметры
        and dl,CHAR_SCALE_MASK          ; выделяем масштабирование
        inc dl                          ; DL = счетчик повторов = масштаб
PrntChr4:
        test al,10000000b               ; проверяем очередной бит шрифта
        jz short PrntChr5
        or dh,cl                        ; устанавливаем бит маски
PrntChr5:
        shl cl,1                        ; сдвигаем бит-модификатор маски
        dec dl                          ; счетчик повторов (для масштаба)
        jnz short PrntChr6
        shl al,1                        ; удаляем бит шрифта из буфера
        dec ah                          ; bits--
        mov dl,bh                       ; битовые параметры
        and dl,CHAR_SCALE_MASK          ; выделяем масштабирование
        inc dl                          ; DL = счетчик повторов = масштаб
PrntChr6:
        dec ch                          ; счетчик пикселей в линии
        jz short PrntChr7               ; закончили линию
        cmp cl,00010000b                ; перешли границу блока?
        jnz short PrntChr3

PrntChr7:
        ; рисуем "столбик" из закрашенных пикселей высотой, равной коэфф-у
        ; масштабирования
        test dh,dh                      ; если маска нулевая, рисовать нечего
        jz short PrntChr8
        push ax
        mov cl,dl                       ; сохраняем счетчик повторов
        mov ah,dh                       ; маска битовых планов
        mov al,02h                      ; адрес регистра VGA
        mov dx,VGA_SEQUENCER_ADDR
        out dx,ax                       ; пишем в регистр маски
        mov dl,bh                       ; битовые параметры
        and dl,CHAR_SCALE_MASK          ; выделяем масштабирование
        inc dl                          ; коэфф-т масштабирования
PrntChr9:
        mov es:[di],bl                  ; пишем в видеобуфер
        add di,GFX_BYTES_PER_LINE       ; переходим на линию ниже
        dec dl
        jnz short PrntChr9              ; следующий пиксель в столбике
        sub di,bp                       ; восстанавливаем позицию
        mov dl,cl                       ; восстанавливаем счетчик повторов
        pop ax

PrntChr8:
        ; переходим к следующему блоку в строке
        inc di                          ; следующий байт в буфере
        mov cl,00000001b                ; сбрасываем позицию в маске
        test ch,ch                      ; сколько пикселей осталось в строке
        jnz short PrntChr2

        ; переходим к следующей строке
        pop di                          ; восстанавливаем позицию в буфере
        pop dx
        pop cx

        add di,bp                       ; на Scale строк вниз
        dec dl                          ; счетчик строк
        jnz short PrntChr1

        ; восстанавливаем сегментные регистры (и доступ к переменным)
        pop es
        pop ds

        ; сдвигаем курсор на ширину символа (с учетом масштаба), проверяем,
        ; влезет ли еще один символ на ту же строку; если нет, спускаемся
        ; на следующую
        mov ch,bh                       ; битовые параметры
        and ch,CHAR_SCALE_MASK          ; выделяем масштабирование
        inc ch                          ; коэфф-т масштабирования
        mov dx,[vx_cursor_x]            ; X курсора
        mov al,[vx_font_width]          ; ширина символа
        mul ch                          ; умножаем на масштаб
        add dx,ax                       ; первый пиксель справа после символа
        mov [vx_cursor_x],dx            ; = новая позиция курсора
        add dx,ax                       ; а еще символ влезет?
        cmp dx,GFX_SCR_WIDTH
        jna short PrntChrR              ; если да, то на выход
        mov dx,[vx_cursor_y]            ; Y курсора
        mov al,[vx_font_height]         ; высота символа
        mul ch                          ; умножаем на масштаб
        add dx,ax
        mov [vx_cursor_y],dx            ; сдвигаем курсор на строчку ниже
        xor ax,ax
        mov [vx_cursor_x],ax            ; и ставим в начало строки

PrntChrR:
        pop bp                          ; восстанавливаем регистры
        pop di
        pop si
        pop dx
        pop cx
        pop bx
        pop ax
        popf
        ret
